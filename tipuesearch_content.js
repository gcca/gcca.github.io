var tipuesearch = {"pages":[{"title":"Intro to Round Robin","text":"Introducción Round Robin es un algoritmo de planificación de procesos. Cada elemento de una lista se selecciona en turno, uno por uno, y cuando se llega al final de la lista, se vuelve al principio. def selection ( choices ): i = 0 while True : yield choices [ i ] i = ( i + 1 ) % len ( choices ) choices = [ 'A' , 'B' , 'C' , 'D' ] s = selection ( choices ) for _ in range ( 10 ): print ( next ( s )) Alternativas Aleatorio (Random Selection): Selecciona elementos de manera aleatoria sin reemplazo hasta que se agoten; luego reinicia el proceso. import random def selection ( choices ): while True : random . shuffle ( choices ) yield from choices choices = [ 'A' , 'B' , 'C' , 'D' ] s = selection ( choices ) for _ in range ( 10 ): print ( next ( s )) Ponderado (Weighted Selection): Cada elemento tiene una probabilidad de ser seleccionado basada en un peso asignado. import random def selection ( choices , weights ): while True : yield random . choices ( choices , weights = weights )[ 0 ] choices = [ 'A' , 'B' , 'C' , 'D' ] weights = [ 1 , 2 , 3 , 4 ] s = selection ( choices , weights ) for _ in range ( 10 ): print ( next ( s )) Least Recently Used (LRU): Selecciona el elemento que ha sido usado hace más tiempo. Simplificada: from collections import deque def selection ( choices ): queue = deque ( choices ) while True : if not queue : queue = deque ( choices ) item = queue . popleft () yield item queue . append ( item ) choices = [ 'A' , 'B' , 'C' , 'D' ] s = selection ( choices ) for _ in range ( 10 ): print ( next ( s )) Prioridad (Priority Queue): Los elementos se seleccionan basándose en una prioridad asignada. Usando heapq (con la prioridad invertida para que funcione como una cola de prioridad mínima) para mantener la prioridad: import heapq def selection ( choices , priorities ): items = [( - p , i ) for p , i in zip ( priorities , choices )] heapq . heapify ( items ) while True : if not items : items = [( - p , i ) for p , i in zip ( priorities , choices )] heapq . heapify ( items ) _ , item = heapq . heappop ( items ) yield item choices = [ 'A' , 'B' , 'C' , 'D' ] priorities = [ 3 , 1 , 4 , 2 ] s = selection ( choices , priorities ) for _ in range ( 10 ): print ( next ( s )) Round Robin es ideal para asegurar una distribución equitativa y predecible. Aleatorio puede ser útil cuando no quieres que haya patrones predecibles. Ponderado es excelente cuando algunos elementos deben ser seleccionados con mayor frecuencia. LRU es útil en sistemas donde la recencia de uso es importante. Prioridad es perfecta para sistemas donde algunos elementos deben ser procesados antes que otros.","tags":"Notes","url":"https://gcca.github.io/2024/10/03/python-roundrobin/","loc":"https://gcca.github.io/2024/10/03/python-roundrobin/"},{"title":"Welcome","text":"Welcome page","tags":"Miscelánea","url":"https://gcca.github.io/2024/02/11/welcome/","loc":"https://gcca.github.io/2024/02/11/welcome/"}]};