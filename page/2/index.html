<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>(gcca) | Page 2</title>
    <link rel="shortcut icon" type="image/png" href="https://gcca.github.io/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="https://gcca.github.io/favicon.ico">
    <link href="https://gcca.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="(gcca) Full RSS Feed" />
    <link rel="stylesheet" href="https://gcca.github.io/theme/css/main.css" type="text/css" />
    <link rel="stylesheet" href="https://gcca.github.io/theme/css/pygments.css" type="text/css" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="(gcca) blog" />
    <meta name="author" content="Cristhian Gonzales" />
</head>
<body>
    <header>
        <nav style="overflow: hidden;">
            <ul>
                <li><a href="https://gcca.github.io/">Home</a></li>
                <li><a href="https://x.com/@gcca_at_x">X</a></li>
                <li><a href="https://github.com/gcca">GitHub</a></li>
                <li><a href="https://gcca.github.io/tags">Tags</a></li>
                <li><a href="https://gcca.github.io/categories">Categories</a></li>
                <li><a href="https://gcca.github.io/archives">Archives</a></li>
            </ul>
        </nav>
        <div class="header_box" style="height: 50px">
        <h1><a href="https://gcca.github.io/">
            <image src='/images/logo.png' class="avatar" width="50px" /><span class="site_title">(gcca)</span>
            </a></h1></div>
            <h2>Blog</h2>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Dec 13, 2024</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://gcca.github.io/2024/12/13/memcpy_nn0_ub/" rel="bookmark" title="Permanent Link to &quot;memcpy(nullptr, nullptr, 0) y otros casos de comportamiento indefinido en C&quot;">memcpy(nullptr, nullptr, 0) y otros casos de comportamiento indefinido en C</a>
                </h2>

                
                

                <p>El comportamiento indefinido (UB) en el lenguaje de programación C es una fuente regular de acaloradas discusiones entre programadores. Por un lado, el UB puede ser importante para las optimizaciones del compilador. Por otro lado, facilita la introducción de errores que pueden llevar a problemas de seguridad.</p>
<p>La buena noticia es que N3322 ha sido aceptado para C2y, lo cual eliminará el comportamiento indefinido de un rincón específico del lenguaje C, haciendo que lo siguiente sea bien definido:</p>
<div class="highlight"><pre><span></span><code><span class="n">memcpy</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="n">memcmp</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="p">;</span>
</code></pre></div>

<p>Esto solo se aplica cuando un puntero nulo se combina con una operación de "longitud cero". Lo siguiente sigue siendo indefinido:</p>
<div class="highlight"><pre><span></span><code><span class="n">memcpy</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">nullptr</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
</code></pre></div>

<p>La eliminación de este comportamiento indefinido no se espera que tenga un impacto negativo en el rendimiento. De hecho, ocurre lo contrario.</p>
<p><strong>Motivación</strong></p>
<p>Los ejemplos anteriores son un poco tontos porque codifican de manera dura una constante NULL/nullptr. Sin embargo, es fácil encontrarse con esta situación con un puntero que a veces es nulo. Por ejemplo, considere una representación típica para una cadena con una longitud conocida:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">str</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="w">   </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<p>Una cadena vacía normalmente se representaría como <code>(struct str) { .data = nullptr, .len = 0 }</code>, con el puntero de datos siendo nullptr. Ahora, considere una función que comprueba si dos cadenas son iguales:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">str_eq</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">str</span><span class="w"> </span><span class="o">*</span><span class="n">str1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">str</span><span class="w"> </span><span class="o">*</span><span class="n">str2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">str2</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">          </span><span class="n">memcmp</span><span class="p">(</span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">str2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Esta implementación parece razonable a primera vista. Sin embargo, muestra comportamiento indefinido si ambas entradas son cadenas vacías. En ese caso, llamaremos a <code>memcmp(nullptr, nullptr, 0)</code>, lo cual es comportamiento indefinido según el estándar de C.</p>
<p>Este tipo de UB introduce el riesgo de que el compilador optimice las comprobaciones de punteros nulos subsiguientes. Por ejemplo, GCC eliminará alegremente la rama <code>dest == nullptr</code> en el siguiente código, mientras que Clang deliberadamente no realiza esta optimización:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">test</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dest</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="c1">// Esta rama será eliminada por GCC debido al comportamiento indefinido.</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>La manera correcta de escribir la función <code>str_eq</code> es:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">str_eq</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">str</span><span class="w"> </span><span class="o">*</span><span class="n">str1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">str</span><span class="w"> </span><span class="o">*</span><span class="n">str2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">str2</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">          </span><span class="p">(</span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span>
<span class="w">           </span><span class="n">memcmp</span><span class="p">(</span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">str2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">str1</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>El nuevo código es correcto, pero peor en todos los demás aspectos:</p>
<ul>
<li>Aumenta el tamaño del código, requiriendo una comprobación adicional en cada sitio de llamada inlinada.</li>
<li>Disminuye el rendimiento, comprobando redundante algo que <code>memcmp</code> debe manejar de todas formas.</li>
<li>Aumenta la complejidad del código.</li>
</ul>
<p>Al mismo tiempo, no hay una manera útil en la que la biblioteca de C pueda aprovechar este comportamiento indefinido para proporcionar una implementación más eficiente. Este es el tipo de UB que no beneficia a nadie y debería ser eliminado del lenguaje.</p>
<p><strong>Aritmética de puntero nulo</strong></p>
<p>La propuesta original se centró en eliminar UB para las llamadas de la biblioteca de memoria, pero un revisor temprano señaló que esto no es suficiente. Después de todo, también necesitamos tener en cuenta cómo se implementan estas funciones de biblioteca.</p>
<p>Por ejemplo, consideremos una implementación típica para una función tipo <code>memcpy</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="n">src</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="o">*</span><span class="n">dst</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>Esta función muestra comportamiento indefinido cuando se llama como <code>copy(nullptr, nullptr, 0)</code>, porque nullptr + 0 es comportamiento indefinido en C.</p>
<p>Para evitar esto, y hacer que el lenguaje sea autoconsistente, necesitamos definir nullptr + 0 como devolviendo nullptr y nullptr - nullptr como devolviendo 0. Esto también alinea C con las semánticas de C++, donde esto ya estaba bien definido.</p>
<p><strong>Oposición</strong></p>
<p>Cuando se discutió esta propuesta en dos reuniones de WG14, la oposición no vino de la dirección que esperaba.</p>
<p>La parte más controvertida de la propuesta fue definir nullptr - nullptr como devolviendo 0. La razón para esto es que cuando los espacios de direcciones entran en juego (que no son parte del C estándar, pero pueden ser implementados como extensión), puede haber múltiples representaciones de un puntero nulo. Asegurarse de que la resta de dos "diferentes" nulos aún resulte en cero podría requerir la generación de código adicional, rompiendo la premisa de que este cambio es completamente gratuito.</p>
<p>Sin embargo, la oposición más vocal vino desde la perspectiva del análisis estático: Haciendo que los punteros nulos sean bien definidos para longitud cero significa que los analizadores estáticos ya no pueden reportar incondicionalmente nullptr siendo pasado a funciones como <code>memcpy</code>—también deben tener en cuenta la longitud ahora. Si un calificador <code>_Optional</code> se introduce en el futuro, los argumentos de <code>memcpy</code> tendrían que ser calificados con él. GCC está considerando la introducción de un atributo <code>nonnull_if_nonzero</code> para representar la nueva precondición.</p>
<p>Después de la discusión aparentemente negativa, me sorprendió que el voto no solo fuera fuertemente a favor del cambio, sino que también viniera con una recomendación a los implementadores para aplicar el cambio retroactivamente a versiones antiguas del estándar. Esto significa que, una vez que los compiladores y las bibliotecas de C hayan implementado el cambio, debería aplicarse incluso sin especificar la bandera -std=c2y.</p>
<p><strong>Funciones integradas del compilador</strong></p>
<p>Trabajo en el medio de la cadena de herramientas de compilador LLVM. Al estar lejos de cualquier parte "orientada al usuario" del compilador, generalmente no estoy involucrado en esfuerzos de estandarización.</p>
<p>La razón por la que me involucré aquí fue la especificación para el intrínseco interno de memcpy de LLVM:</p>
<blockquote>
<p>Los intrínsecos llvm.memcpy.* copian un bloque de memoria desde la ubicación de origen a la ubicación de destino, que deben ser iguales o no superpuestas. [...]</p>
<p>Si <len> es 0, es un no-op modulo el comportamiento de los atributos adjuntos a los argumentos. [...]</p>
</blockquote>
<p>El intrínseco llvm.memcpy puede reducirse a una llamada a la función memcpy, que se trata aquí como un "compilador runtime builtin", aunque en última instancia también es proporcionada por la biblioteca C.</p>
<p>Cuando se usa como un builtin, LLVM requiere que tanto <code>memcpy(x, x, s)</code> como <code>memcpy(nullptr, nullptr, 0)</code> estén bien definidos, aunque el estándar C dice que son UB. GCC y MSVC tienen suposiciones similares.</p>
<p>Hacer que <code>memcpy(nullptr, nullptr, 0)</code> sea oficialmente bien definido elimina una de las suposiciones, mientras que el caso de <code>memcpy(x, x, s)</code> permanece por ahora. Permitir esto fue originalmente también parte de la propuesta, pero más tarde se descartó porque no encajaba bien con los otros cambios.</p>
<p>En un giro extraño de los eventos, este cambio en el estándar de C surgió porque los desarrolladores de Rust seguían quejándose sobre la discrepancia entre las semánticas de LLVM y C.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://gcca.github.io/2024/12/13/memcpy_nn0_ub/">posted at 08:46</a>
                    &nbsp;&middot;&nbsp;<a href="https://gcca.github.io/category/swc-swnews.html" rel="tag">SW.C SW.News</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://gcca.github.io/tag/tips.html" class="tags">Tips</a>
                    &nbsp;<a href="https://gcca.github.io/tag/c.html" class="tags">C</a>
                </div>
            </article>            <h4 class="date">Dec 13, 2024</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://gcca.github.io/2024/12/13/c++14_features/" rel="bookmark" title="Permanent Link to &quot;Algunas características de C++&quot;">Algunas características de C++</a>
                </h2>

                
                

                <h2>Características de C++26</h2>
<h3>Bucles infinitos triviales y UB</h3>
<p>Esta propuesta acerca un poco más a C y C++. El estándar de C++ definía el progreso hacia adelante de manera que asumía que incluso los bucles infinitos triviales terminarían; si no lo hacían, el programa entraba en comportamiento indefinido (UB). Esto es un problema si escribes código de bajo nivel donde estos bucles son comunes. La propuesta añade una definición de una declaración de iteración trivialmente vacía, donde un bucle cuya expresión de control es una expresión constante que evalúa a true es un bucle infinito trivial; ahora estos se incluyen en la definición de progreso hacia adelante. Por ejemplo, en GCC 14, el siguiente fragmento ya no causa comportamiento indefinido (en todos los dialectos de C++, no solo C++26):</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">g</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="w">  </span><span class="cm">/* do something */</span>
<span class="p">}</span>
</code></pre></div>

<h3>Almacenamiento estático para inicializadores con llaves</h3>
<p>Esta propuesta, implementada en GCC 14, permite al compilador optimizar mejor el código que usa <code>std::initializer_list</code>. La implementación de <code>std::initializer_list</code> usa un array de respaldo para sus datos. Antes de esta propuesta, el estándar no permitía al compilador asignar el array de respaldo en almacenamiento estático incluso cuando los datos eran constantes porque todos los arrays de respaldo tenían que ser distintos. Ahora, esta restricción ya no está mandatada, permitiendo que los arrays de respaldo se compartan (lo cual ya era el caso para las cadenas literales). En resumen, GCC 14 optimiza eliminando las llamadas memcpy que copian el array de respaldo en el siguiente fragmento:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;initializer_list&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">il</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">f</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">});</span><span class="w"> </span><span class="c1">// array en .rodata</span>
<span class="p">}</span>
</code></pre></div>

<h3>Cadenas no evaluadas</h3>
<p>GCC 14, en modo C++26, implementa P2361R6, que introduce el concepto de cadenas no evaluadas. Estas cadenas aparecen en contextos como _Pragma, static_assert, o los atributos <code>[[nodiscard]]</code> y <code>[[deprecated]]</code>. No se usan en tiempo de ejecución, por lo que no se convierten a la codificación de ejecución como las cadenas evaluadas. Dado que no se convertirán a otro tipo de codificación de cadena, no pueden contener secuencias de escape numéricas ni prefijos. En la práctica, esto significa que las siguientes dos líneas causarán diagnósticos en modo C++26:</p>
<div class="highlight"><pre><span></span><code><span class="k">static_assert</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="sa">u</span><span class="s">&quot;foo&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// error en C++26</span>
<span class="k">static_assert</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;\x{20}&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// advertencia en C++26 en modo pedántico</span>
</code></pre></div>

<h3><code>constexpr</code> cast desde <code>void*</code></h3>
<p>GCC 14 implementa P2738R1, lo que significa que el siguiente test es aceptado en C++26. Esta característica permite realizar varios trucos de borrado de tipo en código constexpr. (En C++23 y antes, el compilador todavía emitía un error al intentar hacer un cast desde <code>void*</code> en una expresión constante):</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">A</span><span class="o">*</span><span class="w"> </span><span class="n">ap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static_assert</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span>
</code></pre></div>

<h3>Mensajes de static_assert generados por el usuario</h3>
<p>Con esta propuesta implementada en GCC 14, los usuarios pueden usar <code>static_assert</code> de manera más general ya que ahora acepta mensajes generados por el usuario (que deben ser evaluados como constantes). Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">size</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">data</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">static_assert</span><span class="w"> </span><span class="p">(</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">{});</span>
</code></pre></div>

<p>Esto produce el siguiente mensaje de error:</p>
<blockquote>
<p>error: static assertion failed: hello</p>
</blockquote>
<h3>Variables placeholder</h3>
<p>GCC 14 implementa la propuesta P2169R4. Esta propuesta permite usar la variable especial <code>_</code>, que actúa como marcador de posición para una variable sin nombre que no produce el diagnóstico de "variable no usada" incluso cuando no se usa. <code>_</code> también puede redefinir una declaración existente en el ámbito actual (pero usar <code>_</code> generaría un error si más de una variable se ha declarado con ese nombre):</p>
<div class="highlight"><pre><span></span><code><span class="n">X</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="p">();</span>
<span class="kt">void</span>
<span class="nf">g</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">       </span><span class="c1">// OK</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_</span><span class="p">;</span><span class="w">         </span><span class="c1">// error: referencia a ‘_’ es ambigua</span>
<span class="p">}</span>
</code></pre></div>

<h3>Retorno de referencia a temporal</h3>
<p>P2748R5 hace que sea mal formado retornar una referencia a un temporal. GCC ha advertido sobre este tipo de código peligroso por mucho tiempo, pero C++26 lo convierte en un error:</p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="o">&amp;&amp;</span>
<span class="n">foo</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// mal formado en C++26</span>
<span class="p">}</span>
</code></pre></div>

<h2>Características de C++23</h2>
<h3>Deducir this</h3>
<p>GCC 14 implementó esta propuesta, muy solicitada. Permite añadir un parámetro this explícito a las funciones miembro no estáticas; esto se denomina parámetro de objeto explícito. De esta manera, puedes deducir el tipo y la categoría de valor del objeto de la clase. Es útil para evitar la duplicación de código; antes, el desarrollador tenía que escribir varias sobrecargas de funciones miembro: <code>no-const</code>, <code>const</code>, y con calificadores de referencia incluso const <code>&amp;</code> y <code>&amp;&amp;</code> (ignorando detalles como volatile). Con esta propuesta, en lugar de:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">get_add</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">get_add</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">get_add</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="p">(</span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">S</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sr</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">get_add</span><span class="w"> </span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sr</span><span class="p">.</span><span class="n">get_add</span><span class="w"> </span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">i3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">{}.</span><span class="n">get_add</span><span class="w"> </span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">i1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3>Puedes simplificar el código a:</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Self</span><span class="o">&gt;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">get_add</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="n">Self</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="p">{};</span>
<span class="n">s</span><span class="p">.</span><span class="n">get_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">                </span><span class="c1">// Self se deduce como S&amp;</span>
<span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">get_add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w">     </span><span class="c1">// Self se deduce como S</span>
<span class="n">std</span><span class="o">::</span><span class="n">as_const</span><span class="p">(</span><span class="n">s</span><span class="p">).</span><span class="n">get_add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// Self se deduce como const S&amp;</span>
</code></pre></div>

<p>Deducir this también permite escribir lambdas recursivas. Por ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span>
<span class="nf">main</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">fib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">this</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="k">static_assert</span><span class="w"> </span><span class="p">(</span><span class="n">fib</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Hay muchos más ejemplos donde el parámetro de objeto explícito puede ser útil. Tiene algunas restricciones; por ejemplo, una función miembro explícita no puede ser estática o virtual.</p>
<h3>Referencias en expresiones constantes</h3>
<p>Una forma moderna de C++ para implementar una función que obtenga el tamaño de un array puede ser:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Esta función se puede usar como en el siguiente ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="w"> </span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">};</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>El código funciona sin sorpresas. Sin embargo, cuando el array era un parámetro, como en este ejemplo:</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">array_size</span><span class="w"> </span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>El compilador, debido a ciertas reglas bastante complejas, rechazaba el código con el error: ‘arr’ no es una expresión constante. Las reglas se han ajustado y el código funciona como se espera con GCC 14 (en todos los dialectos de C++).</p>
<h3><code>consteval</code> necesita propagarse hacia arriba</h3>
<p>Implementar esta propuesta en GCC 14 resultó algo complicado. Hace que ciertas funciones se promuevan a consteval, es decir, convertir en funciones inmediatas. Considera:</p>
<div class="highlight"><pre><span></span><code><span class="k">consteval</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">id</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"> </span><span class="c1">// id causa que f&lt;int&gt; se promueva a consteval</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">f</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>Anteriormente, el código era inválido y el compilador emitía un error diciendo que t en f no era una expresión constante válida. Con esta propuesta, f se promueve a consteval, lo que significa que la llamada id(t) está en un contexto inmediato, por lo que la llamada no necesita ser una expresión constante. (Así es como funciona la composición de funciones consteval – una función consteval llamando a otra). Ten en cuenta que hacer f<int> consteval implica que la llamada f(3) debe ser una expresión constante válida.</p>
<p>El estándar describe cuáles expresiones causan que su función envolvente se promueva a consteval; estas expresiones se llaman inmediatas-escaladas. Por ejemplo, una llamada a una función inmediata (es decir, consteval) que no es una expresión constante y no es una subexpresión de una invocación inmediata es una expresión inmediata-escalada. No todas las funciones pueden promoverse a consteval. El estándar dice que solo las funciones de escalada inmediata pueden promoverse. Un ejemplo de función de escalada inmediata es una función de plantilla declarada como constexpr.</p>
<p>El comportamiento descrito en la propuesta está habilitado por defecto en el modo C++20 o posterior, pero puedes suprimir la escalada de funciones con la opción de línea de comandos -fno-immediate-escalation.</p>
<h3>CTAD desde constructores heredados</h3>
<p>GCC 14 soporta P2582R1, una propuesta que extiende CTAD (Deducción de Argumentos de Plantilla de Clase) para constructores heredados. Por lo tanto, el siguiente caso de prueba compila en modo C++23:</p>
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<span class="n">B</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">using</span><span class="w"> </span><span class="n">B</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;::</span><span class="n">B</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="n">C</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">// OK, deduce C&lt;int&gt;</span>
</code></pre></div>

<h3>Resolución de informes de defectos</h3>
<p>GCC 14 implementa varias resoluciones de informes de defectos, que generalmente se aplican a todos los dialectos afectados por -std, no solo a los estándares más nuevos. Consulta nuestra tabla de DR de C++ para un estado más detallado.</p>
<h3>stricter constinit</h3>
<p>El problema CWG 2543 aclara que las variables constinit con inicializadores no constantes deben ser diagnosticadas, incluso si la variable podría inicializarse estáticamente.</p>
<h3><code>goto</code> y objetos inicializados trivialmente</h3>
<p>Desde el problema CWG 2256, goto puede cruzar la inicialización de un objeto inicializado trivialmente con un destructor no trivial:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">~</span><span class="n">A</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">goto</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="nl">L</span><span class="p">:</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://gcca.github.io/2024/12/13/c++14_features/">posted at 08:01</a>
                    &nbsp;&middot;&nbsp;<a href="https://gcca.github.io/category/swc-swtips.html" rel="tag">SW.C++ SW.Tips</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://gcca.github.io/tag/tips.html" class="tags">Tips</a>
                    &nbsp;<a href="https://gcca.github.io/tag/c.html" class="tags">C++</a>
                </div>
            </article>            <h4 class="date">Dec 12, 2024</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://gcca.github.io/2024/12/12/rw_urls_nginx/" rel="bookmark" title="Permanent Link to &quot;URLs con nGinx&quot;">URLs con nGinx</a>
                </h2>

                
                

                <p>En <code>nginx</code>, se pueden reescribir URLs con la directiva <code>rewrite</code>. Por ejemplo, para redirigir todas las URLs usando NginxHttpRewriteModule, se puede usar:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="s">(</span><span class="nv">$host</span><span class="w"> </span><span class="p">~</span><span class="sr">*</span><span class="w"> </span><span class="s">&amp;quot</span><span class="p">;</span><span class="k">^sub.dom.com$&amp;quot</span><span class="p">;</span><span class="k">){</span>
<span class="w">  </span><span class="s">rewrite</span><span class="w"> </span><span class="s">^.*(?=\/)(.+)</span>$<span class="w"> </span><span class="s">http://www.dom.com/blog</span><span class="nv">$1</span><span class="w"> </span><span class="s">permanent</span><span class="p">;</span>
<span class="w">  </span><span class="k">break</span><span class="p">;</span>
<span class="k">}</span>
</code></pre></div>

<p>Esto redirige URLs del formato antiguo de http://sub.dom.com/2024/12/12/slug-de-la-página al nuevo formato http://www.dom.com/blog/el-slug-de-la-página (en la capa de nginx) usando <a href="http://www.regular-expressions.info/lookaround.html">lookaround</a>, también conocido como “zero-width positive look-ahead assertion”.</p>
<p>El <em>positive lookahead</em> coincide con el slash (escapado): <code>(?=\/)</code>, sin hacerlo parte de la coincidencia. El símbolo <code>.*</code> significa cualquier carácter y, dado que <code>*</code> consume por defecto, coincide con toda la URL hasta el último carácter de barra diagonal. Finalmente, <code>(.+)</code> forma la primera referencia inversa <code>$1</code> (los lookaheads no crean grupos de captura), la cual se usa en la nueva URL como el segundo argumento para reescribir.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://gcca.github.io/2024/12/12/rw_urls_nginx/">posted at 07:40</a>
                    &nbsp;&middot;&nbsp;<a href="https://gcca.github.io/category/swtips.html" rel="tag">SW.Tips</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://gcca.github.io/tag/tip.html" class="tags">Tip</a>
                </div>
            </article>            <h4 class="date">Nov 20, 2024</h4>

            <article class="post">
                <h2 class="title">
                    <a href="https://gcca.github.io/2024/11/20/perfect_numbers/" rel="bookmark" title="Permanent Link to &quot;Números perfectos&quot;">Números perfectos</a>
                </h2>

                
                

                <p>Un número perfecto es un número entero positivo que es igual a la suma de sus divisores propios positivos, excluyéndose a sí mismo. Por ejemplo,</p>
<ul>
<li><span class="math">\(6 = 1+2+3\)</span>,</li>
<li><span class="math">\(28 = 1+2+4+7+14\)</span>, y</li>
<li><span class="math">\(496 = 1+2+4+8+16+31+62+124+248\)</span>.</li>
</ul>
<h2>Números perfectos pares e impares</h2>
<p>Todos los números perfectos conocidos son pares. No se ha probado que existan números perfectos impares. No se ha demostrado que no existan números perfectos impares. Se han hecho pruebas de algunas propiedades que deberían cumplir los números perfectos impares; por ejemplo, si existen, deben tener al menos 1500 dígitos.</p>
<h2>Primos de Mersenne</h2>
<p>Un primo de Mersenne es un número primo de la forma <span class="math">\(2^p-1\)</span>. Euclídes probó que, si <span class="math">\(M\)</span> es un primo de Mersenne, tenemos que <span class="math">\(M(M+1)/2\)</span> es un número perfecto par [1]. Euler probó el recíproco casi dos milenios después: todo número perfecto par es de la forma <span class="math">\(M(M+1)/2\)</span> donde <span class="math">\(M\)</span> es un primo de Mersenne.</p>
<p>Actualmente hay 52 números perfectos conocidos, todos pares. Se conjetura que hay infinitos primos de Mersenne y los primos de Mersenne conocidos apenas se han ajustado a la proyección de dichos primos, por lo que se sospecha que hay infinitos números perfectos. (Y si los hay, son al menos 52.)</p>
<h2>Números triangulares</h2>
<p>Por el teorema de Euler, todo los números perfectos son de la forma <span class="math">\(M(M+1)/2\)</span>; así los números perfectos pares son números triangulares: <span class="math">\(P = 1+2+3+\cdots+M\)</span>.</p>
<h2>Números binarios</h2>
<p>Los números prefectos pares tienen la forma <span class="math">\(2^{p-1}(2^p-1)\)</span>; así los números prefectos en base binaria consistan de <span class="math">\(p\)</span> unos seguidos de <span class="math">\(p-1\)</span> ceros. Por ejemplo, <span class="math">\(496 = 31\times32/2=2^4(2^5-1)\)</span> y <span class="math">\(496 = 111110000_2\)</span>.</p>
<p>[1]: Euclídes vivió 17 siglos antes que Marin Mersenne y probó que <span class="math">\(2^{p-1}(2^p-1)\)</span> es perfecto si <span class="math">\(2^p-1\)</span> es primo.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
                <div class="clear"></div>

                <div class="info">
                    <a href="https://gcca.github.io/2024/11/20/perfect_numbers/">posted at 07:57</a>
                    &nbsp;&middot;&nbsp;<a href="https://gcca.github.io/category/mathmisc.html" rel="tag">Math.Misc</a>
                    &nbsp;&middot;
                    &nbsp;<a href="https://gcca.github.io/tag/misc.html" class="tags">Misc</a>
                </div>
            </article>

                <div class="clear"></div>
                <div class="pages">

                    <a href="https://gcca.github.io/index.html" class="prev_page">&larr;&nbsp;Previous</a>

                    <a href="https://gcca.github.io/page/3/" class="next_page">Next&nbsp;&rarr;</a>

                    <span>Page 2 of 3</span>
                </div>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/tcarwash/blue-penguin-dark">Blue Penguin Dark</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
                &middot;
                <a href="https://gcca.github.io/feeds/all.rss.xml" rel="alternate">Rss Feed</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
</body>
</html>